---
layout: post
title:  "操作系统: 线程相关概念简介"
date:   2019-09-16 20:02:00 +0700
categories: [os]
---

## 学习目标
1. 搞清楚线程是什么以及它的作用, 线程实现的原理.

## 为什么需要线程?
1. 线程让一个进程内的多个流程的同时运行成为了可能, 而且同一个进程中的线程可以共享进程的地址空间和其中的数据.
2. 线程比进程更加的轻量, 创建线程的代价比创建进程的代价要小的多.

## 经典线程模型
进程与线程的区别是什么?
进程是进行资源分组的手段. 一个进程拥有单独的地址空间, 包括它打开的文件, 子进程都是它的资源.
而线程则是执行的体现, 每个线程都有自己的PC, 栈和变量寄存器.

每个线程都有自己的栈, 每个线程之间互不影响.

## POSIX下的线程
POSIX定义了很多关于线程的函数, 这里我们举几个例子.
- Pthread_create 创建一个新线程, 返回新线程的标识符
- Pthread_exit 终止一个线程
- Pthread_join 等待另一个线程退出
- Pthread_yield 让出cpu给其他线程运行

## 线程的实现
下面我们讨论一下线程的实现方式, 主要有以下两大类: 1. 在用户空间实现 2. 在内核中实现

### 在用户空间实现线程
一种方式是在用户空间实现线程. 在内核中仍然认为进程是一个单线程的, 但是在用户空间为每一个进程都分配一个thread table. 由用户空间的
系统来管理线程的状态(运行或阻塞), 由于在用户空间进行线程的调度管理, 这使得线程的调度十分快几乎没有消耗; 然而缺点也是明显的: 一旦一个线程出现阻塞
系统调用这时候该实现就无法解决了, 而且对于线程饥饿问题该模型也不好解决, 同时最致命的问题在于该模型的性能伸缩性极差, 当一个计算密集型的程序运行时
似乎多线程并没起到什么作用.                 

### 在内核实现线程
在内核维护线程表, 所有线程的创建销毁都由系统调用实现, 内核的线程表保存着每个线程的寄存器和状态和栈信息.
使用内核实现线程解决了上面用户线程的一些问题, 比如:如果有线程出现阻塞, 那么调度器只需要去线程表中查看是否有可以运行的线程就可以,
线程饥饿问题也能解决了, 而且伸缩性也非常高.

### 混合实现
结合用户线程和内核线程的优点, 在用户空间的多个线程绑定到内核线程的一个线程上.
 



 