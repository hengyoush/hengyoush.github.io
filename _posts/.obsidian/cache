{"files":{"2019-04-29-jdk-ConcurrentHashMap-1.md":{"mtime":1556713213148.1306,"size":4015,"hash":"6de857f3733a7d8344e0afbeab59ba6326a8029def14e12e0005d436021b14aa"},"2019-04-29-jdk-ConcurrentHashMap-2.md":{"mtime":1556713213148.283,"size":5229,"hash":"b3a1183595e6b6ce2b2945bb8914e864ed565bd65e9ab6964ce2b38499c438bf"},"2019-04-29-jdk-ConcurrentHashMap-3.md":{"mtime":1556713213148.4224,"size":3625,"hash":"c30b90e47df57ac46dde936e56aa669791eb80d12643b7598f5ab0c9013e4a63"},"2019-04-29-jdk-longadder.md":{"mtime":1556713213148.5796,"size":5794,"hash":"c55f52073c6a41a497a5df2baaf1386d439a8e765b99a48f267f959e745ed531"},"2019-04-29-threadlocal-study.md":{"mtime":1556713213148.7402,"size":8010,"hash":"d76a64eb816b5d9b77b1caf061fc3a5771d78a009598ac1cd6862326980f97f9"},"2019-05-02-codefight-leetcode-322.md":{"mtime":1556857960997,"size":2143,"hash":"439ac7b7a4e9f39090a9c37d52789450e3453014f04325b3dd9d170dab550235"},"2019-05-03-go-gopl-variable.md":{"mtime":1556857986530.1108,"size":2252,"hash":"32bd4f0cec5f599a700348f1a8e479c33c0818c32643332fde8f239213ac3cd8"},"2019-05-04-codefight-leetcode-357.md":{"mtime":1556938733767.401,"size":1536,"hash":"95cbe4e4dcf21b3c57453d95a763abc92194f178367ff4902a7cb994e31849ad"},"2019-05-06-codefight-leetcode-375.md":{"mtime":1557751357853.181,"size":1945,"hash":"3bfb07b75f8d6a6bc1a54dff383cb49c7e43857b98efeacabff38ab367fa60eb"},"2019-05-13-codefight-leetcode-376.md":{"mtime":1557752840380.9822,"size":2615,"hash":"55d412a2038630d200f976592b84bb847e41a4c80f84718212133ab13bb6eb93"},"2019-06-02-kube-pod-label.md":{"mtime":1559461198289.9124,"size":4147,"hash":"4d40ba78167bb9beb2b644d9368644a566ae70a3dbd440e95f5eaf54b8c1dec7"},"2019-06-02-kube-pod-start.md":{"mtime":1559458124155.7256,"size":1911,"hash":"74d5690bb460ae1d9d8197f59e98ae238897bdfb488f8a508a31add72b5bc45e"},"2019-06-02-kube-start.md":{"mtime":1560295950861.9014,"size":4716,"hash":"03057113c1c901da57be51fb523ef52b01ccc768056f746581bcbe7280e81e43"},"2019-06-04-docker-concept.md":{"mtime":1560436809926.866,"size":21043,"hash":"a3fb37d300c9bf37311ffd695b5d7360ffa0e5c784ab921e47a74369fb69e6c9"},"2019-06-09-kuberbetes-concept.md":{"mtime":1560343246021.5388,"size":21918,"hash":"1b26d1f58e54b76547f18581cac1fccda4262ea825011846acf64972cc9a5787"},"2019-06-12-jvm-method-bind.md":{"mtime":1563463832579.7449,"size":5593,"hash":"63c0da2b6a0a8597767ec896ff9d9a4776be9d5dcd7a1acf7ff9f3d6b50fc368"},"2019-07-21-jvm-monitor-concept.md":{"mtime":1563893649455.7625,"size":37919,"hash":"2648cb433e1f7fbf71ded0343ba97def05cc34d03e3c661fb64a33230c1a41e9"},"2019-07-27-netty-memorypool-concept.md":{"mtime":1564190868010.4094,"size":45973,"hash":"25ba936ed2e5f46688e5b6d80bbf6b73fd77362d964e8c2cb85a34099189d570"},"2019-07-29-netty-threadmodel-analysis.md":{"mtime":1564840983248.8284,"size":10347,"hash":"6480e30ae8d3749e12b38d76658562a128ed28556b200578feb336daf729997c"},"2019-09-07-rocketmq-broker-message-handle.md":{"mtime":1568045416932.247,"size":30290,"hash":"1885f2738d2b84fcf3ec2450a29b83db25f4e9d7840eae661093da109e19b53f"},"2019-09-08-operatingsystem-process.md":{"mtime":1568214801083.777,"size":2548,"hash":"dd1a76225249b1f4148dcb4d3668d3f471b0418b4b520810d4516bdddc195e40"},"2019-09-15-rocketmq-indexfile.md":{"mtime":1568530005620.1377,"size":4660,"hash":"05a0a1d197bfbb0e456a9b9df95b30ed0ca7411fcbb40db556dcbf51cb46367d"},"2019-09-16-operatingsystem-thread.md":{"mtime":1568642088505.398,"size":2532,"hash":"8f9415d2fd1016cf4303caa4dadc377e5999763336cf203a97d17e5ea548bc57"},"2019-09-20-jvm-gc-problem.md":{"mtime":1569156172451.9563,"size":5988,"hash":"5ac52829633e6240d80c50e022b4811ca952dbd66881995cc410893abe8c37a2"},"2019-09-20-kube-cluster-create.md":{"mtime":1569156012757.4705,"size":8382,"hash":"545decc284ca2401be2bb05d7e004a1bdaa02d0717ba228a793a5843eeaf3693"},"2019-10-06-jdk-stream-sa.md":{"mtime":1570356855985,"size":15975,"hash":"b7a9fa5fa07c46bd435706c3c42e3c26098bc2bf0aa5a26afc278a0d3c6edd70"},"2020-01-08-rocketmq-dledger-01.md":{"mtime":1578494524638.1943,"size":11988,"hash":"17b31e63d2a1d8e04fc35941e3a61c034482a588af4b98e685b022fc9506e220"},"2020-02-17-rocketmq-dledger-02.md":{"mtime":1581945330142.8274,"size":8426,"hash":"35211fa50e41871c596f75933fe5ecf63728a2d58a9915fecea09ce115fb3651"},"2020-02-18-rocketmq-dledger-03.md":{"mtime":1582074017240.006,"size":6595,"hash":"61baf84651c039505eeb79ffa72178d2f314bf811047dda4881d6cc4d02f8f10"},"2020-02-18-rocketmq-dledger-04.md":{"mtime":1582030616985.647,"size":27861,"hash":"4fa8c0d6e8f5197c283189593c24a2bcf0802a621ca618f1126c635363071fb0"},"2020-06-07-zookeeper-leader-elect.md":{"mtime":1591710869080.5688,"size":10092,"hash":"21508f6a33f3f70dfc7e5c9a658783099a3d6b1b9dcfc02d13f536bb03e280a5"},"2020-06-09-rocketmq-messageconsume.md":{"mtime":1592041137502.4253,"size":53341,"hash":"1f4ba9c9174f47988d3cab520c9b26982d113a94b7bb95756cd0a6c0c381d829"},"2020-06-13-zookeeper-datasync.md":{"mtime":1592134856483.102,"size":16267,"hash":"0f418df4f8021e94c9265e1f2b8597b61b72f6eb9ab0bbccf229d536a5155887"},"2022-06-23-kafka-study.md":{"mtime":1595862632144.9084,"size":7467,"hash":"5a53b2960322021ebbac7405a151f923b9c7ea0fbd6e5904a3a5391f5586f521"},"Kafka核心概念.md":{"mtime":1594560594265.0413,"size":3614,"hash":"4e8c310927cd7b49319ce898b4d78e0b2c5808e30cf665aca681e5dd60b154cc"},"未解决的问题.md":{"mtime":1594568467985.0085,"size":245,"hash":"64f8385886013f926a84d9f3a60cac74f569aa6c2255440ee1e77c71a999f2df"},"2022-06-23-kafka-broker-request-process.md":{"mtime":1594656607367.2397,"size":5193,"hash":"3434ac7f57274ec27941fa7caca94d5c63cb734a050e2374b0fa041a30145188"},"2022-07-27 mosn请求流程笔记.md":{"mtime":1596125183006.0115,"size":4905,"hash":"184d16995e7e2f2e1b4e4de5528d43bed4ef230b39c93d1af6a7089bc6443b52"},"2020-08-02-zookeeper-request-handle.md":{"mtime":1596470033564.5835,"size":1277,"hash":"42772f7e2b0ca66fb008cc9031f8970f489abd26852e5d189e5fed91ad4a4d6d"},"zookeeper客户端请求.png":{"mtime":1596470021485.4412,"size":197290,"hash":"47dd69e689e4765097c55a5c07a972623d21886761c21ef2771dd7de5cfc93e7"}},"metadata":{"6de857f3733a7d8344e0afbeab59ba6326a8029def14e12e0005d436021b14aa":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK源码:ConcurrentHashMap解析(一)-get方法详解\"\ndate:   2019-04-29 18:30:00 +0700\ncategories: [java, jdk]","level":2},{"line":7,"heading":"概述","level":2},{"line":10,"heading":"重要属性解析","level":2},{"line":41,"heading":"读方法解析","level":2},{"line":43,"heading":"get方法解析","level":3},{"line":79,"heading":"ForwardingNode","level":5}]},"b3a1183595e6b6ce2b2945bb8914e864ed565bd65e9ab6964ce2b38499c438bf":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK源码:ConcurrentHashMap解析(二)-位运算详解\"\ndate:   2019-04-29 18:30:00 +0700\ncategories: [java, jdk]","level":2},{"line":7,"heading":"概论","level":2},{"line":10,"heading":"sizeCtl","level":2},{"line":36,"heading":"sizeCtl的深入理解","level":2},{"line":38,"heading":"initTable()","level":4},{"line":67,"heading":"addCount()","level":4},{"line":120,"heading":"helpTransfer()","level":4},{"line":144,"heading":"transfer方法片段","level":4}]},"c30b90e47df57ac46dde936e56aa669791eb80d12643b7598f5ab0c9013e4a63":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK源码:ConcurrentHashMap解析(三)-put解析\"\ndate:   2019-04-29 18:30:00 +0700\ncategories: [java, jdk]","level":2},{"line":7,"heading":"概论","level":2},{"line":11,"heading":"源码","level":2},{"line":17,"heading":"shortCut部分","level":4},{"line":49,"heading":"链表遍历部分","level":4}]},"c55f52073c6a41a497a5df2baaf1386d439a8e765b99a48f267f959e745ed531":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK源码:LongAdder与Striped64解析\"\ndate:   2019-04-29 18:12:00 +0700\ncategories: [java, jdk]","level":2},{"line":7,"heading":"概述","level":2},{"line":12,"heading":"动态分段","level":2},{"line":19,"heading":"主要流程","level":2},{"line":37,"heading":"具体实现","level":2},{"line":129,"heading":"关于sum方法","level":4}]},"d76a64eb816b5d9b77b1caf061fc3a5771d78a009598ac1cd6862326980f97f9":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK源码:ThreadLocal解析\"\ndate:   2019-04-29 18:11:00 +0700\ncategories: [java, jdk]","level":2},{"line":7,"heading":"概述","level":2},{"line":25,"heading":"getEntry方法","level":2},{"line":40,"heading":"getEntryAfterMiss方法猜测","level":4},{"line":44,"heading":"getEntryAfterMiss方法解析","level":4},{"line":77,"heading":"set方法解析","level":2},{"line":79,"heading":"解析前的猜测","level":4},{"line":84,"heading":"Let us 解析!","level":4},{"line":113,"heading":"replaceStaleEntry解析","level":4},{"line":169,"heading":"槽的清理","level":2},{"line":171,"heading":"expungeStaleEntry方法解析","level":4},{"line":216,"heading":"cleanSomeSlots方法解析","level":4},{"line":237,"heading":"备注","level":5}]},"439ac7b7a4e9f39090a9c37d52789450e3453014f04325b3dd9d170dab550235":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Leetcode-322-零钱兑换\"\ndate:   2019-05-02 13:39:00 +0700\ncategories: [algorithm, dynamic programming]","level":2},{"line":7,"heading":"题目","level":2},{"line":10,"heading":"示例1","level":4},{"line":17,"heading":"思路","level":2},{"line":30,"heading":"代码","level":2}]},"32bd4f0cec5f599a700348f1a8e479c33c0818c32643332fde8f239213ac3cd8":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Golang学习:变量命名与声明\"\ndate:   2019-05-03 12:32:00 +0700\ncategories: [golang]","level":2},{"line":6,"heading":"命名","level":2},{"line":11,"heading":"关键字","level":4},{"line":34,"heading":"声明","level":2},{"line":37,"heading":"var关键字","level":3},{"line":46,"heading":"简短变量声明","level":3},{"line":58,"heading":"指针","level":2}]},"95cbe4e4dcf21b3c57453d95a763abc92194f178367ff4902a7cb994e31849ad":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Leetcode-357-计算各个位数不同的数字个数\"\ndate:   2019-05-04 10:07:00 +0700\ncategories: [algorithm, dynamic programming]","level":2},{"line":7,"heading":"题目","level":2},{"line":10,"heading":"示例1","level":4},{"line":17,"heading":"思路","level":2},{"line":37,"heading":"代码","level":2}]},"3bfb07b75f8d6a6bc1a54dff383cb49c7e43857b98efeacabff38ab367fa60eb":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Leetcode-375-猜数字大小 II\"\ndate:   2019-05-06 17:43:00 +0700\ncategories: [algorithm, dynamic programming]","level":2},{"line":7,"heading":"题目","level":2},{"line":17,"heading":"示例","level":4},{"line":31,"heading":"思路","level":2},{"line":36,"heading":"代码","level":2}]},"55d412a2038630d200f976592b84bb847e41a4c80f84718212133ab13bb6eb93":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Leetcode-376-摆动序列\"\ndate:   2019-05-13 20:43:00 +0700\ncategories: [algorithm, dynamic programming]","level":2},{"line":7,"heading":"题目","level":2},{"line":15,"heading":"示例","level":4},{"line":29,"heading":"思路","level":2},{"line":36,"heading":"代码","level":2}]},"4d40ba78167bb9beb2b644d9368644a566ae70a3dbd440e95f5eaf54b8c1dec7":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kubernetes学习: 使用label管理pod\"\ndate:   2019-06-02 15:39:00 +0700\ncategories: [k8s]","level":2},{"line":7,"heading":"困境","level":2},{"line":10,"heading":"label的基本使用","level":2},{"line":12,"heading":"label介绍","level":4},{"line":16,"heading":"如何创建label","level":4},{"line":63,"heading":"修改标签","level":4},{"line":85,"heading":"标签选择器--label selector","level":2},{"line":87,"heading":"基本用法示例","level":4},{"line":123,"heading":"使用标签分类工作节点","level":4}]},"74d5690bb460ae1d9d8197f59e98ae238897bdfb488f8a508a31add72b5bc45e":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kubernetes学习: pod入门\"\ndate:   2019-06-02 14:47:00 +0700\ncategories: [k8s]","level":2},{"line":6,"heading":"使用YAML创建一个pod描述文件","level":4},{"line":36,"heading":"得到pod的完整定义","level":4},{"line":42,"heading":"查看应用程序的日志","level":4},{"line":56,"heading":"向pod中发送请求","level":4}]},"03057113c1c901da57be51fb523ef52b01ccc768056f746581bcbe7280e81e43":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kubernetes学习: 使用minikube在Kubernetes上运行第一个应用\"\ndate:   2019-06-02 13:47:00 +0700\ncategories: [k8s, docker]","level":2},{"line":7,"heading":"准备工作","level":2},{"line":9,"heading":"安装docker","level":3},{"line":14,"heading":"安装VirtualVM","level":3},{"line":17,"heading":"安装kubectl","level":3},{"line":27,"heading":"安装minikube","level":3},{"line":39,"heading":"正式开始","level":2},{"line":41,"heading":"准备一个应用","level":4},{"line":43,"heading":"启动minikube","level":3},{"line":62,"heading":"部署应用","level":3},{"line":87,"heading":"从外部访问应用","level":3},{"line":110,"heading":"水平伸缩应用","level":3},{"line":147,"heading":"dashboard","level":3}]},"a3fb37d300c9bf37311ffd695b5d7360ffa0e5c784ab921e47a74369fb69e6c9":{"links":[],"embeds":[{"line":39,"link":"/static/img/engine-components-flow.png","original":"![avatar](/static/img/engine-components-flow.png)","beforeContext":"","afterContext":"<br><br>下面这张图片则展示了docker的总体架构:"},{"line":44,"link":"/static/img/architecture.svg","original":"![avatar](/static/img/architecture.svg)","beforeContext":"","afterContext":""},{"line":379,"link":"/static/img/types-of-mounts.png","original":"![avatar](/static/img/types-of-mounts.png)","beforeContext":"","afterContext":""},{"line":589,"link":"/static/img/Docker-CI.png","original":"![avatar](/static/img/Docker-CI.png)","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"docker简介以及基本使用\"\ndate:   2019-06-04 13:47:00 +0700\ncategories: [docker]","level":2},{"line":7,"heading":"What is docker？","level":2},{"line":13,"heading":"什么是容器？","level":4},{"line":20,"heading":"容器与虚拟机的相同与不同之处","level":4},{"line":28,"heading":"为什么容器可以实现隔离","level":4},{"line":33,"heading":"Docker的组成","level":4},{"line":50,"heading":"为什么使用Docker","level":2},{"line":62,"heading":"创建镜像","level":2},{"line":65,"heading":"Dockerfile","level":4},{"line":119,"heading":"Dockerfile基本命令参考","level":4},{"line":129,"heading":"使用Dockerfile构建Java应用镜像","level":4},{"line":159,"heading":"使用maven插件创建Java应用镜像","level":4},{"line":161,"heading":"docker-maven-plugin","level":5},{"line":233,"heading":"Jib","level":5},{"line":308,"heading":"常用操作","level":2},{"line":370,"heading":"存储","level":2},{"line":385,"heading":"Volume","level":4},{"line":463,"heading":"Bind mount","level":4},{"line":491,"heading":"网络","level":2},{"line":585,"heading":"Docker与Jenkins持续构建","level":2}]},"1b26d1f58e54b76547f18581cac1fccda4262ea825011846acf64972cc9a5787":{"links":[],"embeds":[{"line":25,"link":"/static/img/K8sOverview-1.png","original":"![avatar](/static/img/K8sOverview-1.png)","beforeContext":"","afterContext":""},{"line":33,"link":"/static/img/Pod-1.png","original":"![avatar](/static/img/Pod-1.png)","beforeContext":"","afterContext":""},{"line":42,"link":"/static/img/Pod-2.svg","original":"![avatar](/static/img/Pod-2.svg)","beforeContext":"","afterContext":""},{"line":133,"link":"/static/img/ReplicationController-1.png","original":"![avatar](/static/img/ReplicationController-1.png)","beforeContext":"","afterContext":""},{"line":208,"link":"/static/img/Deployment-1.png","original":"![avatar](/static/img/Deployment-1.png)","beforeContext":"","afterContext":""},{"line":238,"link":"/static/img/DaemonSet-1.png","original":"![avatar](/static/img/DaemonSet-1.png)","beforeContext":"","afterContext":""},{"line":252,"link":"/static/img/Service-1.png","original":"![avatar](/static/img/Service-1.png)","beforeContext":"","afterContext":""},{"line":371,"link":"/static/img/Ingress-1.png","original":"![avatar](/static/img/Ingress-1.png)","beforeContext":"下图为Ingress的工作流程, 客户端首先对kubia.example.com进行DNS查找, DNS服务器返回了Ingress Controller的IP, 客户端然后通过这个IP对Ingress Controller发送HTTP请求, Controller通过客户端请求的路径匹配到了后端的一个服务, 然后通过与该服务相关联的EndPoint对象查看pod IP, 并将客户端的请求转发给其中一个pod.","afterContext":""},{"line":411,"link":"/static/img/PVPVC-1.png","original":"![avatar](/static/img/PVPVC-1.png)","beforeContext":"","afterContext":""},{"line":429,"link":"/static/img/Resource-1.png","original":"![avatar](/static/img/Resource-1.png)","beforeContext":"","afterContext":""},{"line":446,"link":"/static/img/ConfigMap-1.png","original":"![avatar](/static/img/ConfigMap-1.png)","beforeContext":"","afterContext":""},{"line":450,"link":"/static/img/ConfigMap-2.png","original":"![avatar](/static/img/ConfigMap-2.png)","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kubernetes概念简介\"\ndate:   2019-06-09 13:47:00 +0700\ncategories: [k8s]","level":2},{"line":7,"heading":"背景和k8s的出现","level":2},{"line":15,"heading":"Kubernetes的组成","level":2},{"line":27,"heading":"Pod","level":2},{"line":45,"heading":"Pod中的网络","level":4},{"line":51,"heading":"Pod中的存储","level":4},{"line":56,"heading":"管理Pod","level":4},{"line":63,"heading":"Pod Template","level":4},{"line":83,"heading":"Pod的状态","level":4},{"line":100,"heading":"容器探针","level":4},{"line":124,"heading":"Controller","level":2},{"line":128,"heading":"ReplicaSet","level":3},{"line":170,"heading":"Replication Controller","level":3},{"line":203,"heading":"Deployment","level":3},{"line":212,"heading":"Deployment的定义","level":4},{"line":233,"heading":"DaemonSet","level":3},{"line":242,"heading":"Service","level":2},{"line":254,"heading":"Service的定义","level":3},{"line":305,"heading":"服务发现","level":3},{"line":309,"heading":"通过环境变量发现服务","level":4},{"line":328,"heading":"DNS","level":4},{"line":334,"heading":"发布服务","level":3},{"line":343,"heading":"服务发现相关总结","level":3},{"line":346,"heading":"Ingress--统一管理外部访问","level":3},{"line":394,"heading":"存储","level":2},{"line":396,"heading":"Volume","level":3},{"line":402,"heading":"持久化存储","level":3},{"line":416,"heading":"配置","level":2},{"line":418,"heading":"资源分配","level":3},{"line":427,"heading":"资源抢占","level":3},{"line":442,"heading":"利用ConfigMap解耦配置","level":3}]},"63c0da2b6a0a8597767ec896ff9d9a4776be9d5dcd7a1acf7ff9f3d6b50fc368":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JVM方法执行探究\"\ndate:   2019-07-01 22:00:00 +0700\ncategories: [jvm]","level":2},{"line":19,"heading":"重载的规则","level":2},{"line":28,"heading":"JVM如何识别方法","level":2},{"line":33,"heading":"JVM的静态绑定和动态绑定","level":2},{"line":43,"heading":"方法的符号引用","level":2},{"line":93,"heading":"虚方法","level":2},{"line":102,"heading":"方法表","level":2},{"line":111,"heading":"内联缓存(inline cache)","level":2}]},"2648cb433e1f7fbf71ded0343ba97def05cc34d03e3c661fb64a33230c1a41e9":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JVM字节码monitorenter分析\"\ndate:   2019-07-21 20:18:00 +0700\ncategories: [jvm]","level":2},{"line":7,"heading":"monitorenter","level":2},{"line":13,"heading":"源码分析","level":2},{"line":82,"heading":"分支1:已偏向当前线程","level":4},{"line":95,"heading":"分支2:类markword偏向模式关闭","level":4},{"line":115,"heading":"分支3:epoch不等于class中的epoch，尝试重偏向","level":4},{"line":141,"heading":"分支4:线程id不一致,可能是匿名偏向","level":4},{"line":166,"heading":"轻量级锁重入逻辑","level":3},{"line":190,"heading":"重偏向与撤销","level":3},{"line":317,"heading":"单个对象偏向撤销","level":3},{"line":370,"heading":"批量逻辑","level":3},{"line":436,"heading":"重量级锁","level":2},{"line":582,"heading":"重量级锁竞争逻辑","level":3},{"line":780,"heading":"重量级锁的释放","level":3}]},"25ba936ed2e5f46688e5b6d80bbf6b73fd77362d964e8c2cb85a34099189d570":{"links":[],"embeds":[{"line":20,"link":"/static/img/netty-memalloc-chunklist.webp","original":"![avatar](/static/img/netty-memalloc-chunklist.webp)","beforeContext":"划分的依据是Chunk的空间使用率, 如下, x轴为使用率:","afterContext":"Chunk的初始状态为INIT."},{"line":24,"link":"/static/img/netty-memalloc-huoban.webp","original":"![avatar](/static/img/netty-memalloc-huoban.webp)","beforeContext":"Chunk是一个较大的内存块, 默认为16MB, 一个Chunk默认分为2048个Page, 每个Page大小为16 * 1024 * 1024 / 2048 = 8192 = 8K,Page由一个完全平衡二叉树管理, 其中叶子为2048个Page.","afterContext":"如上图所示, 二叉树高12, 叶节点数目为2^11 = 2048, 正好为一个Chunk中Page的数目.假设我们要在一个尚未开始分配的Chunk中分配一个Tiny类型的空间, 那么它会先判断这个大小会在那一层分配, Tiny小于一个Page的大小所以在11层分配, 接下来如果分配一个18KB的大小, 该大小需要4个Page(分配空间的规范化, 下面会讲到, 实际会分配32KB), 故需要在第九层分配, 512这个节点无法满足, 那么选取的是513这个节点进行分配."},{"line":163,"link":"/static/img/netty-memalloc-chunklist.png","original":"![avatar](/static/img/netty-memalloc-chunklist.png)","beforeContext":"各个ChunkList的关系如下所示:","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Netty内存池原理分析\"\ndate:   2019-07-27 02:00:00 +0700\ncategories: [netty]","level":2},{"line":7,"heading":"Overview","level":2},{"line":52,"heading":"PooledByteBufAllocator","level":2},{"line":141,"heading":"PoolArena初步解析","level":2},{"line":261,"heading":"线程本地缓存分配","level":2},{"line":270,"heading":"MemoryRegionCache","level":3},{"line":409,"heading":"SubpagePool分配","level":2},{"line":452,"heading":"ChunkList分配","level":2},{"line":501,"heading":"Chunk","level":2},{"line":503,"heading":"Chunk结构分析","level":3},{"line":568,"heading":"allocate分析","level":3},{"line":591,"heading":"allocateSubpage","level":4},{"line":710,"heading":"PoolSubpage结构分析","level":3},{"line":874,"heading":"PooledByteBuf在Chunk中的初始化","level":3},{"line":937,"heading":"内存的回收","level":2},{"line":938,"heading":"Subpage内存的释放","level":3},{"line":974,"heading":"Chunk内存的释放","level":3},{"line":1007,"heading":"ChunkList中内存的释放","level":3},{"line":1044,"heading":"Arena中内存的释放","level":3},{"line":1083,"heading":"总结","level":2}]},"6480e30ae8d3749e12b38d76658562a128ed28556b200578feb336daf729997c":{"links":[],"embeds":[{"line":10,"link":"/static/img/netty-threadmodel-eventloopclasspic.png","original":"![avatar](/static/img/netty-threadmodel-eventloopclasspic.png)","beforeContext":"","afterContext":""},{"line":44,"link":"/static/img/netty-threadmodel-reactor.png","original":"![avatar](/static/img/netty-threadmodel-reactor.png)","beforeContext":"","afterContext":"下面解释一下这张图片里几个组件的作用."},{"line":57,"link":"/static/img/netty-threadmodel-subreactor.png","original":"![avatar](/static/img/netty-threadmodel-subreactor.png)","beforeContext":"在此我们将以最经典的Reactor模型来阐述Reactor模式的工作流程.","afterContext":""},{"line":66,"link":"/static/img/netty-threadmodel-eventloop.png","original":"![avatar](/static/img/netty-threadmodel-eventloop.png)","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Netty线程模型分析\"\ndate:   2019-08-03 21:50:00 +0700\ncategories: [netty]","level":2},{"line":7,"heading":"概述","level":2},{"line":43,"heading":"Reactor模式简介","level":2},{"line":56,"heading":"Reactor模式流程","level":2},{"line":65,"heading":"Netty的线程模型","level":2},{"line":71,"heading":"关键源码分析","level":2},{"line":72,"heading":"一. `ServerBootstrapAcceptor`作用分析","level":3},{"line":149,"heading":"二. ChildGroup的注册Channel流程","level":3}]},"1885f2738d2b84fcf3ec2450a29b83db25f4e9d7840eae661093da109e19b53f":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Rocketmq broker消息存储流程\"\ndate:   2019-09-08 02:06:00 +0700\ncategories: [rocketmq]","level":2},{"line":7,"heading":"源码阅读目标","level":2},{"line":10,"heading":"前置准备","level":2},{"line":12,"heading":"Netty服务端","level":3},{"line":43,"heading":"消息解码","level":4},{"line":96,"heading":"消息分发","level":5},{"line":143,"heading":"CommitLog消息存储","level":2},{"line":146,"heading":"消息处理","level":3},{"line":174,"heading":"CommitLog的putMessage方法解析","level":3},{"line":265,"heading":"MappedFile的创建","level":3},{"line":353,"heading":"消息append","level":3},{"line":391,"heading":"消息commit以及刷盘分析","level":3},{"line":437,"heading":"消息commit的具体分析","level":4},{"line":519,"heading":"消息刷盘的具体分析","level":4},{"line":552,"heading":"ConsumeQueue","level":2}]},"dd1a76225249b1f4148dcb4d3668d3f471b0418b4b520810d4516bdddc195e40":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"操作系统: 进程相关概念简介\"\ndate:   2019-09-11 23:13:00 +0700\ncategories: [OS]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"进程","level":2},{"line":12,"heading":"进程的定义","level":4},{"line":16,"heading":"进程的创建:","level":4},{"line":27,"heading":"进程的终止:","level":4},{"line":35,"heading":"进程的分层:","level":4},{"line":38,"heading":"进程的状态","level":4},{"line":51,"heading":"进程的实现","level":4}]},"05a0a1d197bfbb0e456a9b9df95b30ed0ca7411fcbb40db556dcbf51cb46367d":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Rocketmq IndexFile源码解读\"\ndate:   2019-09-15 10:02:00 +0700\ncategories: [rocketmq]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"IndexFile的作用","level":2},{"line":13,"heading":"IndexFile的组成","level":2},{"line":37,"heading":"Hash冲突解决方案","level":2},{"line":78,"heading":"根据key定位条目物理位移流程源码解读","level":2}]},"8f9415d2fd1016cf4303caa4dadc377e5999763336cf203a97d17e5ea548bc57":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"操作系统: 线程相关概念简介\"\ndate:   2019-09-16 20:02:00 +0700\ncategories: [os]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"为什么需要线程?","level":2},{"line":14,"heading":"经典线程模型","level":2},{"line":21,"heading":"POSIX下的线程","level":2},{"line":28,"heading":"线程的实现","level":2},{"line":31,"heading":"在用户空间实现线程","level":3},{"line":37,"heading":"在内核实现线程","level":3},{"line":42,"heading":"混合实现","level":3}]},"5ac52829633e6240d80c50e022b4811ca952dbd66881995cc410893abe8c37a2":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"线上GC问题排查\"\ndate:   2019-09-20 20:02:00 +0700\ncategories: [jvm]","level":2},{"line":7,"heading":"出现线上GC问题时处理步骤：","level":2},{"line":55,"heading":"PermGen耗尽造成的频繁GC","level":2}]},"545decc284ca2401be2bb05d7e004a1bdaa02d0717ba228a793a5843eeaf3693":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"K8s集群搭建步骤: 单master\"\ndate:   2019-09-20 20:02:00 +0700\ncategories: [k8s]","level":2},{"line":8,"heading":"安装必要软件","level":2},{"line":25,"heading":"设置 yum repository","level":2},{"line":33,"heading":"安装并启动 docker","level":2},{"line":40,"heading":"安装 nfs-utils","level":2},{"line":46,"heading":"关闭 防火墙","level":2},{"line":52,"heading":"关闭 SeLinux","level":2},{"line":58,"heading":"关闭 swap","level":2},{"line":65,"heading":"修改 /etc/sysctl.conf","level":2},{"line":83,"heading":"配置K8S的yum源","level":2},{"line":97,"heading":"卸载旧版本","level":2},{"line":100,"heading":"安装kubelet、kubeadm、kubectl","level":2}]},"b7a9fa5fa07c46bd435706c3c42e3c26098bc2bf0aa5a26afc278a0d3c6edd70":{"links":[],"embeds":[{"line":53,"link":"/static/img/jdk-stream-lianbiao.png","original":"![avatar](/static/img/jdk-stream-lianbiao.png)","beforeContext":"链表结构stream中的每一步操作最终的表示形式是链表结构的.如下图所示, 我们的示例代码最终会表示成如下形式.","afterContext":""},{"line":137,"link":"/static/img/jdk-stream-pipeline-class.png","original":"![avatar](/static/img/jdk-stream-pipeline-class.png)","beforeContext":"该方法new了一个ReferencePipeline.Head对象, 这个对象就是我们之前提到的链表结构的头部.Head相关的类图如下所示:","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"JDK8 stream api源码简单分析\"\ndate:   2019-10-06 18:12:00 +0700\ncategories: [jdk,sa]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"开篇","level":2},{"line":20,"heading":"概念","level":2},{"line":59,"heading":"源码解析","level":2},{"line":82,"heading":"ArrayListSpliterator源码解析","level":3},{"line":220,"heading":"TerminalOp执行过程解析","level":3},{"line":374,"heading":"总结","level":2}]},"17b31e63d2a1d8e04fc35941e3a61c034482a588af4b98e685b022fc9506e220":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Dledger中Candidate选举流程\"\ndate:   2020-01-08 22:20:00 +0700\ncategories: [rocketmq,raft]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"源码分析","level":2},{"line":81,"heading":"处理投票请求","level":2},{"line":128,"heading":"对投票结果的处理","level":2},{"line":260,"heading":"转变为Leader","level":2},{"line":271,"heading":"与原本的Raft算法的不同之处","level":2}]},"35211fa50e41871c596f75933fe5ecf63728a2d58a9915fecea09ce115fb3651":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Dledger中Leader和Follower流程详解\"\ndate:   2020-02-17 15:20:00 +0700\ncategories: [rocketmq,raft]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"源码分析","level":2},{"line":14,"heading":"Leader","level":3},{"line":121,"heading":"Follower","level":3}]},"61baf84651c039505eeb79ffa72178d2f314bf811047dda4881d6cc4d02f8f10":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Dledger中日志追加流程概述\"\ndate:   2020-02-18 15:20:00 +0700\ncategories: [rocketmq,raft]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"源码分析","level":2}]},"4fa8c0d6e8f5197c283189593c24a2bcf0802a621ca618f1126c635363071fb0":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Dledger中日志追加流程详解\"\ndate:   2020-02-18 15:20:00 +0700\ncategories: [rocketmq,raft]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"源码分析","level":2},{"line":32,"heading":"EntryDispatcher","level":3},{"line":290,"heading":"EntryHandler","level":3},{"line":487,"heading":"QuorumAckChecker","level":3}]},"21508f6a33f3f70dfc7e5c9a658783099a3d6b1b9dcfc02d13f536bb03e280a5":{"links":[],"embeds":[{"line":239,"link":"/static/img/选举流程.png","original":"![avatar](/static/img/选举流程.png)","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Zookeeper Leader选举流程源码解读\"\ndate:   2020-06-01 15:20:00 +0700\ncategories: [zookeeper]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"源码分析","level":2},{"line":236,"heading":"总结","level":2}]},"1f4ba9c9174f47988d3cab520c9b26982d113a94b7bb95756cd0a6c0c381d829":{"links":[],"embeds":[{"line":1081,"link":"/static/img/消息消费流程.png","original":"![avatar](/static/img/消息消费流程.png)","beforeContext":"流程图","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Rocketmq 消息消费过程源码分析\"\ndate:   2020-06-09 10:02:00 +0700\ncategories: [rocketmq]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":11,"heading":"基于推模式下的消息消费过程分析","level":2},{"line":22,"heading":"使用示例","level":3},{"line":137,"heading":"消费者启动流程","level":3},{"line":220,"heading":"队列负载","level":3},{"line":274,"heading":"ProcessQueue","level":4},{"line":314,"heading":"消费请求发送","level":3},{"line":339,"heading":"Broker端对消费请求的处理","level":3},{"line":453,"heading":"Broker端长轮询的实现","level":4},{"line":543,"heading":"消息拉取回调","level":3},{"line":564,"heading":"消息消费过程以及消费结果处理","level":3},{"line":648,"heading":"细节: 消费进度的计算策略","level":3},{"line":710,"heading":"顺序消费","level":2},{"line":713,"heading":"使用示例","level":3},{"line":785,"heading":"队列负载以及加锁处理","level":3},{"line":858,"heading":"顺序消息消费以及消费结果处理","level":3},{"line":931,"heading":"定时消息","level":3},{"line":1080,"heading":"总结","level":2}]},"0f418df4f8021e94c9265e1f2b8597b61b72f6eb9ab0bbccf229d536a5155887":{"links":[],"embeds":[{"line":328,"link":"/static/img/成员发现&数据同步.png","original":"![avatar](/static/img/成员发现&数据同步.png)","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Zookeeper Leader成员发现以及数据同步流程源码分析\"\ndate:   2020-06-13 15:20:00 +0700\ncategories: [zookeeper]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":14,"heading":"成员发现","level":2},{"line":17,"heading":"Leader的初始化过程","level":3},{"line":90,"heading":"FOLLOWER的初始化流程","level":3},{"line":117,"heading":"创建新的epoch","level":3},{"line":170,"heading":"数据同步","level":2},{"line":187,"heading":"数据同步--DIFF、TRUNC还是SNAP?","level":3},{"line":325,"heading":"总结","level":2}]},"5a53b2960322021ebbac7405a151f923b9c7ea0fbd6e5904a3a5391f5586f521":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kafka源码学习笔记\"\ndate:   2020-06-13 15:20:00 +0700\ncategories: [kafka]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":11,"heading":"分区副本","level":3},{"line":23,"heading":"ISR","level":4},{"line":30,"heading":"消息发送的坑,要注意避免","level":3},{"line":39,"heading":"拦截器","level":3},{"line":41,"heading":"事务型 Producer","level":3},{"line":44,"heading":"重平衡触发的条件","level":3},{"line":66,"heading":"重平衡详解","level":3},{"line":85,"heading":"消费位移管理","level":3},{"line":104,"heading":"Producer创建连接的时机","level":3},{"line":110,"heading":"Consumer如何管理连接","level":3},{"line":116,"heading":"Broker如何处理请求","level":3},{"line":123,"heading":"高水位与Leader Epoch","level":3}]},"4e8c310927cd7b49319ce898b4d78e0b2c5808e30cf665aca681e5dd60b154cc":{"links":[],"embeds":[],"tags":[],"headings":[{"line":0,"heading":"Kafka核心概念","level":1},{"line":1,"heading":"目标","level":2},{"line":5,"heading":"概念","level":2}]},"64f8385886013f926a84d9f3a60cac74f569aa6c2255440ee1e77c71a999f2df":{"links":[],"embeds":[],"tags":[],"headings":[]},"3434ac7f57274ec27941fa7caca94d5c63cb734a050e2374b0fa041a30145188":{"links":[{"line":97,"link":"2022-06-23-kafka-broker-request-process#细节 处理client端请求的有序性是如何保证的","original":"[[2022-06-23-kafka-broker-request-process#细节 处理client端请求的有序性是如何保证的]]","displayText":"","beforeContext":"对read事件,读取channel中的请求数据将其放入到selecor的completedReceives属性中,将channel置为mute状态.(参见:","afterContext":")"}],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Kafka源码学习笔记 之 Broker端是如何处理请求的\"\ndate:   2020-07-13 15:20:00 +0700\ncategories: [kafka]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":10,"heading":"SocketServer的初始化","level":2},{"line":34,"heading":"连接的Accept","level":2},{"line":69,"heading":"Processor线程循环","level":2},{"line":104,"heading":"细节:处理client端请求的有序性是如何保证的","level":3},{"line":107,"heading":"RequestHandler","level":2}]},"184d16995e7e2f2e1b4e4de5528d43bed4ef230b39c93d1af6a7089bc6443b52":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"mosn请求流程笔记\"\ndate:   2020-07-27 15:20:00 +0700\ncategories: [service mesh,mosn]","level":2},{"line":7,"heading":"学习目标","level":2}]},"c8abc7bb43c745d7af5dc7358a1ef3ba318e845f879474c12345cc802b145792":{"links":[],"embeds":[],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Zookeeper请求处理全流程\"\ndate:   2020-08-02 17:20:00 +0700\ncategories: [zookeeper]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":11,"heading":"temp","level":2},{"line":29,"heading":"Packet","level":4},{"line":39,"heading":"总结","level":2}]},"47dd69e689e4765097c55a5c07a972623d21886761c21ef2771dd7de5cfc93e7":{"links":[],"embeds":[],"tags":[],"headings":[]},"faf4f52956d94e390779d7f7d58f32e0a1bae4259b4ada0d89e18ee4979846d2":{"links":[],"embeds":[{"line":40,"link":"zookeeper客户端请求.png","original":"![[zookeeper客户端请求.png]]","beforeContext":"下面是流程图:","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Zookeeper请求处理全流程\"\ndate:   2020-08-02 17:20:00 +0700\ncategories: [zookeeper]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":11,"heading":"temp","level":2},{"line":29,"heading":"Packet","level":4},{"line":39,"heading":"总结","level":2}]},"42772f7e2b0ca66fb008cc9031f8970f489abd26852e5d189e5fed91ad4a4d6d":{"links":[],"embeds":[{"line":38,"link":"zookeeper客户端请求.png","original":"![[zookeeper客户端请求.png]]","beforeContext":"","afterContext":""}],"tags":[],"headings":[{"line":1,"heading":"layout: post\ntitle:  \"Zookeeper请求处理全流程\"\ndate:   2020-08-02 17:20:00 +0700\ncategories: [zookeeper]","level":2},{"line":7,"heading":"学习目标","level":2},{"line":11,"heading":"temp","level":2},{"line":29,"heading":"Packet","level":4},{"line":39,"heading":"总结","level":2}]}},"algorithmVersion":9}