---
layout: post
title:  "mosn请求流程笔记"
date:   2020-07-27 15:20:00 +0700
categories: [service mesh,mosn]
---

## 学习目标
学习mosn的请求处理流程

connPerGoroutine:
```go
startRWLoop:
  connection.startReadLoop
    connection.doRead
	  c.readBuffer.ReadOnce(c.rawConnection)
	  c.onRead
	    c.filterManager.OnRead()
```

FilterManager的处理逻辑
```go
FilterManager.onContinueReading
  activeReadFilter.filter.OnData(fm.conn.GetReadBuffer())
```

proxy/proxy.go的处理逻辑
```go
proxy.serverStreamConn.Dispatch(buf)
  streamConn.Dispatch(buf)
  frame = streamConn.protocol.Decode(buf)
  // 如果读到了足够多的数据
  streamConn.handleFrame(streamCtx, frame)
    sc.handleRequest(frame)
	
```

conn/streamConn.go
handleRequest方法处理逻辑
```go
if frame.IsHeartbeatFrame() {
  // 处理心跳逻辑
}

serverStream := sc.newServerStream(ctx, frame)
proxy.NewStreamDetect
  downstream = newActiveStream // downstream是一个重要的东西
  downstream.OnReceive
    ~ downStream.receive
```

downstream的receive方法将downstream请求的处理分为如下几步:
1. InitPhase:这一步基本什么也不做直接到下一步
2. DownFilter:这一步执行downstream的receiverFilters(估计这个receiverFilters有大用处)
3. MatchRoute:这一步根据请求头返回一个routeHandlerChain,然后开始执行这个chain,最终给downstream  
的route和snapshot赋值(snapshot是upstream集群的快照信息,里面包含集群的host集合和负载均衡器)
```go
downstream.matchRoute()
  routersImpl.CallMakeHandlerChain
    DefaultMakeHandlerChain
	  routersImpl.MatchRoute(headers)
	    routersImpl.findVirtualHost(headers) // 根据virtualHost的domain配置可能返回默认的
  s.snapshot, s.route = handlerChain.DoNextHandler()
```
4. DownFilterAfterRoute:路由之后再次执行downstream的receiverFilters.
5. ChooseHost:因为已经确定上游集群了,接下来开始确定集群中的host.
```go
downStream.chooseHost()
  s.cluster = s.snapshot.ClusterInfo()
  s.initializeUpstreamConnectionPool
    connPool = s.proxy.clusterManager.ConnPoolForCluster(s.snapshot, currentProtocol) // 这里会进行连接池的创建和初始化
	  clusterManager.getActiveConnectionPool // 这里会进行负载均衡
	    clusterSnapshot.LoadBalancer().ChooseHost(balancerContext)
  s.requestInfo.OnUpstreamHostSelected(pool.Host()) // 设置host
```
6. DownFilterAfterChooseHost:选择host之后运行receiverFilter
7. DownRecvHeader





