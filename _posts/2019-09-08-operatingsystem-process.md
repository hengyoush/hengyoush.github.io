---
layout: post
title:  "操作系统: 进程相关概念简介"
date:   2019-09-11 23:13:00 +0700
categories: [OS]
---

## 学习目标
1. 搞清楚UNIX进程模型以及创建终止的过程(不要求源码级别的了解, 了解流程即可)

## 进程

#### 进程的定义
进程就是一个执行中程序的实例, 包括程序计数器(Program counter), 寄存器, 和变量信息.
概念上, 每个进程都有自己的虚拟cpu, 但实际上我们知道是cpu在不同的进程之间来回切换.

#### 进程的创建:
何时会创建?
1. 系统初始化
2. 其他进程进行系统调用创建进程
3. 用户请求创建进程
4. 批处理job的初始化

以上四种本质上都是一个已存在的进程进行一个创建进程的系统调用, 指明要运行的程序.在UNIX中, 只存在一个系统调用——fork是创建新的进程的.
当进程A fork出进程B时, A和B具有相同的内存image, 相同的环境变量和相同的文件句柄. 子进程在后续过程中一般会调用execve来创建自己的内存image
并且运行一个新的程序.(此处表述有待改进)

#### 进程的终止:
一般分为两种:
1. 主动退出
2. 被动退出

当一个进程正常执行完毕, 它会进行一个系统调用exit告诉操作系统, 这种终止属于主动退出.
而被动退出主要是由于程序的bug导致的, 还有可能是因为其他进程进行一个系统调用告诉操作系统去kill掉某个进程.

#### 进程的分层:
UNIX中当一个进程创建另一个进程时, 这种父子进程关系就建立起来了. 每个进程都只有最多一个父进程, 可以有0个或多个子进程.

#### 进程的状态
1. Running
2. Ready
3. Blocked
状态之间的转换如下所示
```
                1, 2cpu的调度
          Running<=======>Ready
           |              ^ 4 外部条件满足
3 外部条件   |             | 
           |-> Blocked--——|
```

#### 进程的实现
操作系统维护着一个表, 这个表里面的每一项代表着每个进程, 表项里面包含着进程的重要信息, 包括:
寄存器, PC, status, 栈指针, pid 和 内存相关的:进程的text段地址,data段地址和stack段地址等等.
这个表叫做process table, 也叫做process control blocks, PCB.

当中断发生时, 系统会将process table中的对应进程的表项压入当前进程的栈之中, 然后跳转到
interrupt vector中找到对应中断的handler进行中断的处理. 当完成之后, 系统又会将stack中的信息加载回register中开始
继续运行.
