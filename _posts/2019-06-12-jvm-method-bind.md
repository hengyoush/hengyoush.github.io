---
layout: post
title:  "JVM方法执行探究"
date:   2019-07-01 22:00:00 +0700
categories: [jvm]
--- 

首先看一个小例子，有两个方法如下：
```java
void foo(Object o, Object...objs);
void foo(String s, Object obj, Object...objs);

foo(null, 1); // 调用2
foo(null, 2, 1); // 调用2
foo(null, new Object[]{1}); // 避开可变参数，调用1
```

这是由于`null`相比`String`和`Object`，与String更加接近。故重载时选择了第二个方法。

## 重载的规则
重载方法选取的规则如下：
1. 不考虑对基本类型装箱拆箱的情况下选取重载方法。
2. 如果第一步没有选到，那么运行装箱拆箱的情况下不允许变长参数的情况下选取重载方法。
3. 如果第二步没有找到，那么在允许装箱拆箱的情况下而且允许变长参数的情况下选取重载方法。

此外如果编译器在同一个阶段中找到了多个匹配的方法，那么它选择其中一个最为贴切的方法，决定贴切程度的关键就是
类的继承关系.

## JVM如何识别方法
类名,方法名,方法描述符(method descriptor):由方法的参数类型和返回类型组成.如果出现名字相同且方法描述符也相同的方法,JVM在验证阶段报错.
**JVM**对于重写的判断是基于名字相同且方法描述符也相同的情况.
对于 Java 语言中重写而 Java 虚拟机中非重写的情况,编译器会生成桥接方法.

## JVM的静态绑定和动态绑定
重载的区分在编译阶段已经完成, 是为静态绑定.重写被称为动态绑定.

字节码中与方法调用相关的指令有五种.
1. `invokestatic`: 调用静态方法
2. `invokespecial`: 调用私有实例方法、构造器、默认方法等
3. `invokevirtual`: 调用非私有实例方法
4. `invokeinterface`: 调用接口方法
5. `invokedynamic`: 调用动态方法

## 方法的符号引用
看如下代码:
```java
public class Test {
    public static void main(String[] args) {
        A a = new B();
        a.isA(); // interfaceMethodRef
        B b = (B) a;
        b.S(); // MethodRef
    }

    interface A {
        void isA();
    }

    static class B implements A {

        public void S() {}

        @Override
        public void isA() {

        }
    }
}
```

使用`javap -v Test.class`得到该类的字节码, 下面是`main`方法的片段

```java
...
9: invokeinterface #4,  1            // InterfaceMethod com/aliware/tianchi/Test$A.isA:()V
...
20: invokevirtual #5                  // Method com/aliware/tianchi/Test$B.S:()V
...
```
可以看到`isA`方法是`InterfaceMethod`, 而`S`方法是`Method`, 这两个方法的符号引用在解析的时候是具有不同的行为的.

对于`Method`, 有如下解析步骤:
1. 先在本类中查找是否存在相同方法名和方法描述符的方法(这一步会发生*静态方法隐藏*)
2. 如果上一步没有找到, 那么向上回溯, 直到Object重复1.
3. 如歌没有找到, 在该类中实现的接口或间接实现的接口中寻找, 这一步寻找的目标方法必须是非静态的(接口中定义的静态方法必须由接口来调用, 否则java编译器会报错),非私有的.这一步有可能向上回溯.

对于`InterfaceMethod`, 有如下解析步骤:
1. 在I中查找相同方法名和方法描述符的方法
2. 在Object中的公有实例方法中寻找
3. 在I的超接口中寻找

经过如上的解析步骤, 符号引用被解析为实际引用, 对于静态绑定的方法而言, 实际引用是一个方法指针, 对于动态绑定而言, 实际引用是指向方法表条目的索引.

## 虚方法
虚方法指非私有实例方法和接口方法.虚方法的调用在字节码中是invokevirtual(非私有实例方法)指令和invokeinterface(接口方法)指令.

这两种方法都需要在运行时确定调用者的类型, 来确定到底该调用哪个类的方法, 称为动态绑定. 而一些方法的调用在编译时就可以确定, 这称为静态绑定.
如调用静态方法的`invokestatic`和调用私有实例方法和父类非私有实例方法和构造器等的`invokespecial`, 另外如果虚方法调用指向的是`final`标记的方法
也会静态绑定.

那么为了能确定动态绑定调用的是哪个方法就需要一种对应关系, 这个对应关系就是**方法表**.

## 方法表
有虚方法表和接口方法表之分, 这里先分析虚方法表(virtual method table, vtable).

方法表本质上是一个数组, 每个元素指向一个当前类和其祖先类中非私有实例方法.其遵循以下两个条件:
- 子类方法表中包含父类方法表中所有方法.
- 子类方法表中重写父类的方法在方法表中的索引是相同的.

在方法执行过程中, 虚拟机获取调用者的真实类型, 再通过方法表中的索引找到真正要调用的方法, 在方法解析的过程中, 实际引用实际上是方法表的索引.

## 内联缓存(inline cache)
内联缓存是针对多态的优化手段. 针对多态的优化手段中缓存类型的情况, 我们可分为以下三种:

1. 单态(monomorphic) 指仅有一种状态的情况.
2. 多态(polymorphic) 指有限状态的情况, 二态是多态情况的一种.
3. 超多态(megamorphic) 指比多态更多的情况, 一般有一个有限值做区分.

对内联缓存来说, 对应这三种也有不同的类型. 在JVM中使用的是单态内联缓存.
那么对于单态内联缓存来说, 如果存在动态类型没有命中的情况, JVM不会丢弃以前的缓存来更新缓存的, 它会退化为超多态, 直接去方法表中寻找.



